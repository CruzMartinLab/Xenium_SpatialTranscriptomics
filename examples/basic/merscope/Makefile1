# --------- workflow for Vizgen MERSCOPE data

 # ─── Configurable parameters ────
GITPATH      := {GITPATH}
RAWDIR	     := {RAWDIR}
COMPRESSED   := {COMPRESSED}
DATADIR      := {DATADIR}
TMPDIR       := {TMPDIR}
# NUCLEIRADIUS := {NUCLEIRADIUS}

THREADS      := {THREADS}
SEED         := {SEED}
TILESIZE     := {TILESIZE}
HEXGRIDS     := {HEXGRIDS}
TOPICS       := {TOPICS}
PIXHEX       := {PIXHEX}
NMOVE        := {NMOVE}
RES          := {RES}
SCALE        := {SCALE}


PUNKST       := $(GITPATH)/bin/punkst
FEATURES     := $(DATADIR)/features.txt
TRANSCRIPTS  := $(DATADIR)/transcripts.tsv
CELLCOORD    := $(DATADIR)/cell_coordinates.tsv
COORDRANGE   := $(DATADIR)/coord_range.txt
TILETSV      := $(DATADIR)/transcripts.tiled.tsv
TILEINDEX    := $(DATADIR)/transcripts.tiled.index
ICOL_X       := 1
ICOL_Y       := 2
ICOL_FEATURE := 4
ICOL_COUNT   := 5
SKIP 	     := 1

TAB := $(shell printf '\t')

ifeq ($(COMPRESSED), 1)
	RAW_METADATA = $(RAWDIR)/cell_metadata.csv.gz
	CAT_CMD = zcat
else
	RAW_METADATA = $(RAWDIR)/cell_metadata.csv
	CAT_CMD = cat
endif

# ─── Compute the full list of final report files ──────────────────────────
REPORTS := \
  $(foreach H,$(HEXGRIDS),\
    $(foreach K,$(TOPICS),\
      $(DATADIR)/k$(K)_hex_$(H).$(PIXHEX)_$(NMOVE)_$(RES).factor.info.html\
	  $(DATADIR)/k$(K)_hex_$(H).$(PIXHEX)_$(NMOVE)_$(RES).pixel.png\
    )\
  )

.PHONY: all clean
all: prepare $(REPORTS)



# ─── Step 0. Prepare‐data ─────────────────────────────────────────────────
prepare: $(CELLCOORD) $(FEATURES) $(TRANSCRIPTS) $(COORDRANGE)

$(CELLCOORD) $(COORDRANGE):
	$(CAT_CMD) $(RAW_METADATA) | cut -d',' -f 4-9 | tail -n +2 | awk -F',' -v OFS="\t" -v out="$(CELLCOORD)" ' \
	    NR==1 {{ \
	        xmin = $$3; ymin = $$4; \
	        xmax = $$5; ymax = $$6; \
	    }} \
	    {{ \
	        if (xmin>$$3) xmin=$$3; \
			if (ymin>$$4) ymin=$$4; \
			if (xmax<$$5) xmax=$$5; \
			if (ymax<$$6) ymax=$$6; \
	        print $$1, $$2 > out; \
	    }} \
	    END {{ \
	        print "XMIN:=" xmin > "$(COORDRANGE)"; \
	        print "XMAX:=" xmax >> "$(COORDRANGE)"; \
	        print "YMIN:=" ymin >> "$(COORDRANGE)"; \
	        print "YMAX:=" ymax >> "$(COORDRANGE)"; \
	    }}'

-include $(COORDRANGE)

$(FEATURES):
ifeq ($(COMPRESSED),1)
	@echo "Extracting gene names from compressed data..."
	zcat $(RAWDIR)/cell_by_gene.csv.gz | head -n 1 | sed 's/,/\n/g' | tail -n +2 | grep -v Blank > $@
else
	@echo "Extracting gene names from uncompressed data..."
	head -n 1 $(RAWDIR)/cell_by_gene.csv | sed 's/,/\n/g' | tail -n +2 | grep -v Blank > $@
endif

$(TRANSCRIPTS):
ifeq ($(COMPRESSED),1)
	@echo "Extracting transcripts from compressed data..."
	zcat $(RAWDIR)/detected_transcripts.csv.gz \
	  | cut -d',' -f2-5,9 \
	  | sed \
	      -e '0,/barcode/{{s/barcode/#barcode/}}' \
	      -e 's/,/$(TAB)/g' \
	      -e 's/$$/$(TAB)1/' \
	      -e '0,/barcode/{{s/$(TAB)1$$/$(TAB)count/}}' \
	    > $@
else
	@echo "Extracting transcripts from uncompressed data..."
	cut -d',' -f2-5,9 $(RAWDIR)/detected_transcripts.csv \
	  | sed \
	      -e '0,/barcode/{{s/barcode/#barcode/}}' \
	      -e 's/,/$(TAB)/g' \
	      -e 's/$$/$(TAB)1/' \
	      -e '0,/barcode/{{s/$(TAB)1$$/$(TAB)count/}}' \
	    > $@
endif

# ─── Step 1: bag pixels → tiles.tsv + tiles.index ─────────────────────
$(TILETSV) $(TILEINDEX): $(TRANSCRIPTS)
	@echo "[1/6] pts2tiles → $@"
	/usr/bin/time -v $(PUNKST) pts2tiles \
	  --in-tsv $(TRANSCRIPTS) \
	  --icol-x $(ICOL_X) --icol-y $(ICOL_Y) --skip $(SKIP) \
	  --tile-size $(TILESIZE) \
	  --tile-buffer 1000 \
	  --out-prefix $(DATADIR)/transcripts.tiled \
	  --temp-dir $(TMPDIR) --threads $(THREADS)

# ─── Step 2: for each H in HEXGRIDS → hex_H_randomized.txt ────────────
define HEX_RULE
$(DATADIR)/hex_$(1)_randomized.txt $(DATADIR)/hex_$(1).json: \
    $(TILETSV) \
    $(TILEINDEX) \
    $(FEATURES)
	@echo "[2/6] tiles2hex (hex=$(1)) → $$@"
	/usr/bin/time -v $(PUNKST) tiles2hex \
	  --in-tsv $(TILETSV) \
	  --in-index $(TILEINDEX) \
	  --feature-dict $(FEATURES) \
	  --icol-x $(ICOL_X) --icol-y $(ICOL_Y) \
	  --icol-feature $(ICOL_FEATURE) \
	  --icol-int $(ICOL_COUNT) \
	  --hex-grid-dist $(1) \
	  --min-count 50 \
	  --out $(DATADIR)/hex_$(1).txt \
	  --temp-dir $(TMPDIR) --threads $(THREADS)
	sort -k1,1 --parallel $(THREADS) \
	  $(DATADIR)/hex_$(1).txt > $(DATADIR)/hex_$(1)_randomized.txt
	rm $(DATADIR)/hex_$(1).txt
endef
$(foreach H,$(HEXGRIDS),$(eval $(call HEX_RULE,$H)))

# ─── Step 3: for each (K,H) → model.tsv + color.rgb.tsv ──────────────
define LDA_MODEL_RULE
$(DATADIR)/k$(2)_hex_$(1).model.tsv $(DATADIR)/k$(2)_hex_$(1).results.tsv: \
    $(DATADIR)/hex_$(1)_randomized.txt \
    $(DATADIR)/hex_$(1).json
	@echo "[3/6] lda4hex (K=$(2), hex=$(1)) → $$@"
	/usr/bin/time -v $(PUNKST) lda4hex \
	  --in-data $(DATADIR)/hex_$(1)_randomized.txt \
	  --in-meta $(DATADIR)/hex_$(1).json \
	  --n-topics $(2) \
	  --out-prefix $(DATADIR)/k$(2)_hex_$(1) \
	  --transform --min-count-train 50 --minibatch-size 512 \
	  --threads $(THREADS) --seed $(SEED) --n-epochs 1
endef
$(foreach H,$(HEXGRIDS),\
  $(foreach K,$(TOPICS),\
    $(eval $(call LDA_MODEL_RULE,$H,$K))\
  )\
)

define COLOR_RULE
$(DATADIR)/k$(2)_hex_$(1).color.rgb.tsv: \
    $(DATADIR)/k$(2)_hex_$(1).results.tsv
	@echo "[3/6] color_helper (K=$(2), hex=$(1)) → $$@"
	python $(GITPATH)/ext/py/color_helper.py \
	  --input $(DATADIR)/k$(2)_hex_$(1).results.tsv \
	  --output $(DATADIR)/k$(2)_hex_$(1).color \
	  --cmap-name nipy_spectral \
	  --seed $(SEED)
endef
$(foreach H,$(HEXGRIDS),\
  $(foreach K,$(TOPICS),\
    $(eval $(call COLOR_RULE,$H,$K)) \
  )\
)

# ─── Step 4: pixel-decode → .tsv + .pseudobulk.tsv ────────────────────
define PIXEL_RULE
$(DATADIR)/k$(2)_hex_$(1).$(PIXHEX)_$(NMOVE)_$(RES).tsv \
$(DATADIR)/k$(2)_hex_$(1).$(PIXHEX)_$(NMOVE)_$(RES).pseudobulk.tsv: \
    $(DATADIR)/k$(2)_hex_$(1).model.tsv \
    $(TILETSV) \
    $(TILEINDEX)
	@echo "[4/6] pixel-decode (K=$(2), hex=$(1)) → $$*.tsv"
	/usr/bin/time -v $(PUNKST) pixel-decode \
	  --model $(DATADIR)/k$(2)_hex_$(1).model.tsv \
	  --in-tsv $(TILETSV) \
	  --in-index $(TILEINDEX) \
	  --out-pref $(DATADIR)/k$(2)_hex_$(1).$(PIXHEX)_$(NMOVE)_$(RES) \
	  --icol-x $(ICOL_X) \
	  --icol-y $(ICOL_Y) \
	  --icol-feature $(ICOL_FEATURE) \
	  --icol-val $(ICOL_COUNT) \
	  --hex-grid-dist $(PIXHEX) \
	  --n-moves $(NMOVE) \
	  --min-init-count 20 \
	  --pixel-res $(RES) \
	  --temp-dir $(TMPDIR) --threads $(THREADS) --seed $(SEED) \
	  --output-original --output-coord-digits 2 --output-prob-digits 4
endef
$(foreach H,$(HEXGRIDS),\
  $(foreach K,$(TOPICS),\
    $(eval $(call PIXEL_RULE,$H,$K))\
  )\
)

# ─── Step 5: draw-pixel-factors → .png ───────────────────────────
define DRAW_RULE
$(DATADIR)/k$(2)_hex_$(1).$(PIXHEX)_$(NMOVE)_$(RES).pixel.png: \
    $(DATADIR)/k$(2)_hex_$(1).$(PIXHEX)_$(NMOVE)_$(RES).tsv \
    $(DATADIR)/k$(2)_hex_$(1).color.rgb.tsv \
	$(COORDRANGE)
	@echo "[5/6] draw-pixel-factors (K=$(2), hex=$(1)) → $$@"
	/usr/bin/time -v $(PUNKST) draw-pixel-factors \
	  --in-tsv $(DATADIR)/k$(2)_hex_$(1).$(PIXHEX)_$(NMOVE)_$(RES).tsv \
	  --in-color $(DATADIR)/k$(2)_hex_$(1).color.rgb.tsv \
	  --out $$@ \
	  --xmin $(XMIN) --xmax $(XMAX) --ymin $(YMIN) --ymax $(YMAX) \
	  --scale $(SCALE)
endef
$(foreach H,$(HEXGRIDS),\
  $(foreach K,$(TOPICS),\
    $(eval $(call DRAW_RULE,$H,$K))\
  )\
)

# ─── Step 6: de_bulk + factor_report → final .report ───────────────
define REPORT_RULE
$(DATADIR)/k$(2)_hex_$(1).$(PIXHEX)_$(NMOVE)_$(RES).factor.info.html: \
    $(DATADIR)/k$(2)_hex_$(1).$(PIXHEX)_$(NMOVE)_$(RES).pseudobulk.tsv \
    $(DATADIR)/k$(2)_hex_$(1).color.rgb.tsv
	@echo "[6/6] de_bulk+factor_report (K=$(2), hex=$(1)) → $$@"
	python $(GITPATH)/ext/py/de_bulk.py \
	  --input $(DATADIR)/k$(2)_hex_$(1).$(PIXHEX)_$(NMOVE)_$(RES).pseudobulk.tsv \
	  --output $(DATADIR)/k$(2)_hex_$(1).$(PIXHEX)_$(NMOVE)_$(RES).de_bulk.tsv \
	  --feature_label Feature --thread $(THREADS)
	python $(GITPATH)/ext/py/factor_report.py \
	  --de $(DATADIR)/k$(2)_hex_$(1).$(PIXHEX)_$(NMOVE)_$(RES).de_bulk.tsv \
	  --pseudobulk $(DATADIR)/k$(2)_hex_$(1).$(PIXHEX)_$(NMOVE)_$(RES).pseudobulk.tsv \
	  --feature_label Feature \
	  --color_table $(DATADIR)/k$(2)_hex_$(1).color.rgb.tsv \
	  --output_pref $(DATADIR)/k$(2)_hex_$(1).$(PIXHEX)_$(NMOVE)_$(RES)
endef
$(foreach H,$(HEXGRIDS),\
  $(foreach K,$(TOPICS),\
    $(eval $(call REPORT_RULE,$H,$K))\
  )\
)

# ─── Clean up all generated files ──────────────────────────────────
clean:
	rm -rf $(TMPDIR) \
	       $(DATADIR)/transcripts.tiled.* \
	       $(DATADIR)/hex_*_randomized.txt \
	       $(DATADIR)/k*_hex_*
